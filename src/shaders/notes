https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps

------------------------------------------------------------------------

To summarize, we can implement hardware variance shadow maps as follows:

Render to the variance shadow map by using a linear depth metric (Listing 8-4), outputting depth and depth squared (Listing 8-2). Use multisample antialiasing (MSAA) on the shadow map (if it's supported).
Optionally blur the variance shadow map by using a separable box filter.
Generate mipmaps for the variance shadow map.
Render the scene, projecting the current fragment into light space as usual, but using a single, filtered (anisotropic and trilinear) texture lookup into the variance shadow map to retrieve the two moments.
Use Chebyshev's inequality to compute p max (Listing 8-1).
Optionally, apply light-bleeding reduction to p max (Listing 8-3).
Use p max to attenuate the light contribution caused by shadowing.

------------------------------------------------------------------------

// --------------------------------
// Listing 8-1
// --------------------------------
// Render variance shadow map from the light's point of view. 
DepthPSIn Depth_VS(DepthVSIn In) {   
    DepthPSIn Out;   
    Out.Position = mul(float4(In.Position, 1), g_WorldViewProjMatrix);   
    Out.PosView  = mul(float4(In.Position, 1), g_WorldViewMatrix);   
    return Out; 
} 
    
float4 Depth_PS(DepthPSIn In) : SV_Target {
    float DistToLight = length(In.PosView);
    return ComputeMoments(DistToLight); 
}
    
// Render and shade the scene from the camera's point of view.    
float4 Shading_PS(ShadingPSIn In) : SV_Target {   
    // Compute the distance from the light to the current fragment.    
    float SurfaceDistToLight = length(g_LightPosition – In.PosWorld);   
    . . . 
}

// --------------------------------
// Listing 8-2
// --------------------------------
float2 ComputeMoments(float Depth) {
    float2 Moments;
    // First moment is the depth itself.
    Moments.x = Depth;
    // Compute partial derivatives of depth.
    float dx = ddx(Depth);
    float dy = ddy(Depth);
    // Compute second moment over the pixel extents. 
    Moments.y = Depth*Depth + 0.25*(dx*dx + dy*dy); 
    return Moments; 
}

// --------------------------------
// Listing 8-1
// --------------------------------
float ChebyshevUpperBound(float2 Moments, float t) {
    // One-tailed inequality valid if t > Moments.x 
    float p = (t <= Moments.x);
    // Compute variance.
    float Variance = Moments.y – (Moments.x*Moments.x);
    Variance = max(Variance, g_MinVariance);
    // Compute probabilistic upper bound.    
    float d = t – Moments.x;
    float p_max = Variance / (Variance + d*d);
    return max(p, p_max);
} 
                              
float ShadowContribution(float2 LightTexCoord, float DistanceToLight) {
    // Read the moments from the variance shadow map.    
    float2 Moments = texShadow.Sample(ShadowSampler, LightTexCoord).xy;   
    // Compute the Chebyshev upper bound.    
    return ChebyshevUpperBound(Moments, DistanceToLight); 
}


// Listing 8-3

float linstep(float min, float max, float v) {   
    return clamp((v – min) / (max – min), 0, 1); 
} 

float ReduceLightBleeding(float p_max, float Amount) {
    // Remove the [0, Amount] tail and linearly rescale (Amount, 1].
    return linstep(Amount, 1, p_max); 
} 